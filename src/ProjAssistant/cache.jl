## ----------------------------------------------------------------------------
# GLOBALS
const GLOBALS = Dict()
const TEMP_CACHE_FILE_PREFIX = "temp_cache"
const DATA_KEY = :dat
 
function _init_globals()
    empty!(GLOBALS)
    GLOBALS[:CACHE_DIR] = pwd()
    GLOBALS[:VERBOSE] = true
end

# TODO make a Cache struct for storing useful data id, file, data type, mod time, etc
## ----------------------------------------------------------------------------
set_cache_dir(cache_dir::String) = (GLOBALS[:CACHE_DIR] = cache_dir)
get_cache_dir() = GLOBALS[:CACHE_DIR]
set_verbose(verbose::Bool) = (GLOBALS[:VERBOSE] = verbose)
get_verbose() = GLOBALS[:VERBOSE]
set_fileid(fileid) = (GLOBALS[:FILEID] = string(fileid))
get_fileid() = GLOBALS[:FILEID]

is_temp_cache_file(file) = startswith(file, TEMP_CACHE_FILE_PREFIX)
 
temp_cache_file(hashtable, cache_dir = get_cache_dir(), ext = ".jld") = 
    joinpath(cache_dir, string(TEMP_CACHE_FILE_PREFIX, "___", hash(hashtable), ext))

## ----------------------------------------------------------------------------
function _save_cache(hashtable, data; 
        cache_dir = get_cache_dir(), headline = "CACHE SAVED",
        verbose = get_verbose(), onerr::Function = (err) -> rethrow(err), 
        print_fun = println
    )

    tcache_file = temp_cache_file(hashtable, cache_dir) |> relpath
    try
        serialize(tcache_file, Dict(DATA_KEY => data))
        verbose && print_fun(headline, 
                "\ncache_file: ", tcache_file,
                "\nsize: ", filesize(tcache_file), " bytes",
                "\ndata type: ", typeof(data),
                "\n"
            )
    catch err
        verbose && print_fun("ERROR SAVING CACHE\n", 
                "\ncache_file: ", tcache_file, 
                "\n", err_str(err),
                "\n"
            )

        onerr(err)
    end
    return hashtable
end

save_cache(hashtable, data; keargs...) = _save_cache(hashtable, data; keargs...)
save_cache(f::Function, hashtable; kwargs...) = 
    _save_cache(hashtable, f(); kwargs...)

function _save_cache(data; cache_dir = get_cache_dir(), kwargs...) 
    rf = tempname(cache_dir; cleanup = false) # just create a random mess
    hashtable = (:AUTOGENERATED, hash(rf))
    _save_cache(hashtable, data; cache_dir, kwargs...)
    return hashtable
end
save_cache(data; kwargs...) = _save_cache(data; kwargs...)
save_cache(f::Function; kwargs...) = _save_cache(f(); kwargs...)

## ----------------------------------------------------------------------------
function _load_cache(f::Function, hashtable::Any; 
        cache_dir = get_cache_dir(), 
        headline = "CACHE LOADED",
        verbose = get_verbose(), 
        onerr::Function = (err) -> rethrow(err),
        savecache = true,
        print_fun = println
    )

    tcache_file = temp_cache_file(hashtable, cache_dir) |> relpath
    
    try
        if isfile(tcache_file)
            data = deserialize(tcache_file)[DATA_KEY]
        else
            data = f()
            savecache && save_cache(hashtable, data; 
                cache_dir, verbose, onerr, print_fun
            )
        end

        verbose && print_fun(headline, 
                "\ncache_file: ", tcache_file,
                "\nsize: ", filesize(tcache_file), " bytes",
                "\ndata type: ", typeof(data), 
                "\n"
            )

        return data
    catch err
        verbose && print_fun("ERROR LOADING CACHE\n", 
                "\ncache_file: ", tcache_file, 
                "\n", err_str(err),
                "\n"
            )

        return onerr(err)
    end
end    

load_cache(f::Function, hashtable::Any; kwargs...) = 
    _load_cache(f, hashtable; kwargs...)
load_cache(hashtable::Any, dflt = nothing; kwargs...) = 
    _load_cache(() -> dflt, hashtable; savecache = false, kwargs...)

## ----------------------------------------------------------------------------
function delete_cache(hashtable; cache_dir = get_cache_dir(), force = true)
    tcache_file = temp_cache_file(hashtable, cache_dir)
    rm(tcache_file, force = true, recursive = true)
end

function delete_temp_caches(cache_dir = get_cache_dir(); 
        verbose = get_verbose(), print_fun = println
    )
    tcaches = filter(file -> startswith(file, TEMP_CACHE_FILE_PREFIX), readdir(cache_dir))
    for tc in tcaches
        tc = joinpath(cache_dir, tc)
        rm(tc, force = true)
        verbose && print_fun(relpath(tc), " deleted!!!")
    end
end

## ----------------------------------------------------------------------------
exist_cache(hashtable; cache_dir = get_cache_dir()) = 
    isfile(temp_cache_file(hashtable, cache_dir))
    
## ----------------------------------------------------------------------------
function backup_temp_cache(cache_dir, backup_dir = cache_dir * "_backup")
    files = readdir(cache_dir)
    !isdir(backup_dir) && mkpath(backup_dir)
    for file in files
        !is_temp_cache_file(file) && continue
        src_file, dest_file = joinpath(cache_dir, file), joinpath(backup_dir, file)
        isfile(dest_file) && mtime(src_file) < mtime(dest_file) && continue
        cp(src_file, dest_file; force = true, follow_symlinks = true)
    end
end